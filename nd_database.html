<h1>N-Dimensional arrays with decent locality</h1>
<p>
	At some point in a person's life, there comes a time where a dataset has more than one dimension.
	It is imperative to their career that the datastructure they choose for this is regular,
	and ordered for the most relevant dimension(s).
</p><p>
	What we will be doing today is none of that. We want to be cool and esoteric with it.<br/>
	We want a datastructure where similar coordinates in space result in similar indices in linear memory.
	An important implication of this is that selecting a subsection of the total dataset becomes a more local
	operation as well, regardless of the direction or dimensionality that subsection has.
</p>
	<h2>The normal approach</h2>
<p>
	The standard way to save any amount of dimensions in a contiguous array is where every dimension consists of its subdimensions.
	A 2D array is a collection of many 1D lines, a 3D array is a collection of 2D slices, and so forth.
	Any particular coordinate is indexed like so:
<pre><code class="c">int index = 0;
for (int dim = amount_of_dimensions - 1; dim > 0; dim -= 1) {
	index *= dimension_sizes[dim];
	index += coordinate[dim];
}
</code></pre>
	A notable assumption here is that any particular dimension will have a maximum index (a size). This is a reasonable assumption,
	so in this article, we will accept it.
</p><p>
	This approach is great for a number of reasons, and can be tailored for datasets where one thing is more important than another.
	However, it lacks locality. Incrementing along the 'lower' dimensions results in small index changes, but these index distances
	increase rapidly as you increment along the 'higher' dimensions.
</p><p>
	This 'favoritism' for lower dimensions is the problem of interest, and one we'd like to solve.
</p>
	<h2>A more local approach</h2>
<p>
	We can take any space and split it in half in any particular direction. If we do this for all orthogonal directions,
	we end up with a space of the same proportions as the original, but half the size (when measured along its edges).<br/>
	On this remaining space, we can perform that same splitting operation, and continue until we've zeroed in on an
	arbitrarily specific spot in space.
</p><p>
	This splitting in half, and choosing a side, can be encoded with a single bit: 0 for low, 1 for high.
	To select down to a specific spot, we need to both keep track of which orthogonal direction (aka dimension) we've split along,
	as well as how many times we've done the split.
	A 3D, 4-split example:
<table>
<!--  <colgroup>
    <col span="2" />
    <col class="column-background" />
    <col class="column-fixed-width" />
    <col class="column-background" />
    <col class="column-background-border" />
    <col span="2" class="column-fixed-width" />
  </colgroup>-->
  <tr>
    <td>&nbsp;</td>
    <th>dim 0</th>
    <th>dim 1</th>
    <th>dim 2</th>
  </tr>
  <tr>
    <th>split 0</th>
    <td>1</td>
    <td>1</td>
    <td>0</td>
  </tr>
  <tr>
    <th>split 1</th>
    <td>1</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr>
    <th>split 2</th>
    <td>0</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr>
    <th>split 3</th>
    <td>0</td>
    <td>1</td>
    <td>1</td>
  </tr>
</table>
</p><p>
	This table holds an interesting insight: When we collect bits column-wise, per dimension (1100, 1001, 0111),
	we end up with the coordinates that we singled in on! (in big-endian)
	This is true because the binary encoding of a number <em>is</em> binary partitioning along a number line.
</p><p>
	Something more interesting happens when we collect the bits row-wise, per split. We end up with 4 numbers
	(110, 101, 001, 011) that each represent a selection of a progressively smaller region.
<!--
</p><p>
	Let's take a 3D example of an array with the following dimensions:
<pre><code>int dimension_sizes[3];
dimension_sizes[0] = 525;
dimension_sizes[1] = 66;
dimension_sizes[2] = 2275;
</code></pre>
	given a coordinate (<code>x, y, z</code>) and using the given method, the index would be:
<pre><code>int index = 66*575*z + 575*y + x;
</code></pre>
</p><p>
	Now we'll take a small leap of faith, and decompose the dimension sizes into their prime factors.
<pre><code>int dimension_sizes[3];
dimension_sizes[0] = 2 * 5 * 5 * 7 ;
dimension_sizes[1] = 2 * 3 * 11    ;
dimension_sizes[2] = 5 * 5 * 7 * 13;
</code></pre>
	Notice how we're multiplying these values as rows in a table. Instead, we'll multiply them as columns.
<pre><code>int resolution_levels[4];
resolution_levels[0] = 7 *      13;
resolution_levels[1] = 5 * 11 * 7 ;
resolution_levels[2] = 5 * 3  * 5 ;
resolution_levels[3] = 2 * 2  * 5 ;
</code></pre>-->
</p>
