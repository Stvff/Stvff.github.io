<h1 id="top">N-Dimensional arrays with decent locality</h1>
<p>
	At some point in a person's life, there comes a time where a dataset has more than one dimension.
	It is imperative to their career that the datastructure they choose for this is regular,
	and ordered for the most relevant dimension(s).
</p><p>
	What we will be doing today is none of that. We want to be cool and esoteric with it.<br/>
	We want a datastructure where similar coordinates in space result in similar indices in linear memory.
	This property is known as locality, and is often desired in high performance programs.
</p>
	<h2>The normal approach</h2>
<p>
	The standard way to save any amount of dimensions in a contiguous array is where every dimension consists of its subdimensions.
	A 2D array is a collection of many 1D lines, a 3D array is a collection of 2D slices, and so forth.
	Any particular coordinate is indexed like so:
<pre><code class="c">int index = 0;
for (int dim = amount_of_dimensions - 1; dim >= 0; dim -= 1) {
	index *= dimension_sizes[dim];
	index += coordinate[dim];
}
</code></pre>
	A notable assumption here is that any particular dimension will have a maximum index (a size). This is a reasonable assumption,
	so in this article, we will accept it.
</p><p>
	This approach is great for a number of reasons, and can be tailored for datasets where one thing is more important than another.
	However, it lacks locality. Incrementing along the 'lower' dimensions results in small index changes, but these index distances
	increase rapidly as you increment along the 'higher' dimensions.
</p><p>
	This 'favoritism' for lower dimensions is the problem of interest, and one we'd like to solve.
</p>
	<h2>A more local approach</h2>
<p>
	We can take any space and split it in half in any particular direction. If we do this for all orthogonal directions,
	we end up with a space of the same proportions as the original, but half the size (when measured along its edges).<br/>
	On this remaining space, we can perform that same splitting operation, and continue until we've zeroed in on an
	arbitrarily specific spot in space. This is binary space partitioning, or at least one application of it.
</p><p>
	This splitting in half, and choosing a side, can be encoded with a single bit: 0 for low, 1 for high.
	To select down to a specific spot, we need to both keep track of which orthogonal direction (aka dimension) we've split along,
	as well as how many times we've done the split.
	A 3D, 4-split example:
<table>
	<tr> <td>&nbsp;</td>  <th>dim 0</th> <th>dim 1</th> <th>dim 2</th> </tr>
	<tr> <th>split 0</th> <td>1</td>     <td>1</td>     <td>0</td>     </tr>
	<tr> <th>split 1</th> <td>1</td>     <td>0</td>     <td>1</td>     </tr>
	<tr> <th>split 2</th> <td>0</td>     <td>0</td>     <td>1</td>     </tr>
	<tr> <th>split 3</th> <td>0</td>     <td>1</td>     <td>1</td>     </tr>
</table>
</p><p>
	This table holds an interesting insight: When we collect bits column-wise, per dimension (1100, 1001, 0111),
	we end up with the coordinates that we zeroed in on! (in big-endian)
	This is true because the binary encoding of a number <em>is</em> binary partitioning along a number line.
</p><p>
	Something more interesting happens when we collect the bits row-wise, per split. We end up with 4 numbers
	(110, 101, 001, 011) that each represent a selection of a progressively smaller region. In fact,
	when the coordinates change their least significant bits, only the smallest subselections change. This
	is exactly the property we are looking for.
</p>
	<h3>Moving towards implementation details</h3>
<p>
	From here on, the next question is: how do we combine these 4 numbers to form a standard 1D index?
	The same concept used for standard indexing can be applied here, but instead we'll pretend like we
	have a 4D coordinate. The size of each 'dimension' becomes the total amount of values possible for
	each subselection, which is 8 (since it's 3 bits).
	Using the earlier described algorithm for indexing, we end up with:
<pre><code class="c">int index = 8*8*8*0b110 + 8*8*0b101 + 8*0b001 + 0b011;
</code></pre>
	Of course, that means we might as well have just concatenated all bits in one number: 110101001011.
</p><p>
	Given an existing array with known dimensions, how do we know the amount of splits we need to do?
	We take the base 2 logarithm of the largest dimension size. The "base 2 logarithm" would be defined like this:
<pre><code class="c">int log_2(int n) {
	int power = 0;
	if (n == 0) return power;
	while (n != 0) {
		n >>= 1;
		power += 1;
	}
	return power;
}
</code></pre>
	And the usage in practice would be like so:
<pre><code class="c">int amount_of_splits = 0;
for (int dim = 0; dim &lt; amount_of_dimensions; dim += 1) {
	int power = log_2(dimension_sizes[dim]);
	if (power > amount_of_splits) amount_of_splits = power;
}
</code></pre>
	It should be noted that, if <code>amount_of_splits</code> Ã— <code>amount_of_dimensions</code> exceeds 48,
	your array is too large to be directly indexed by a modern x86-64 CPU. Depending on the
	dimension sizes, this could be partially mitigated by a more efficient packing
	(as we will see in the next chapter), but otherwise you will have to resort to splitting your
	index (and array) across multiple pointers.
</p><p>
	Now that we have the amount of splits, we can convert standard coordinates to our BSP index:
<pre><code class="c">int index = 0;
for (int shift = amount_of_splits - 1; shift &gt;= 0; shift -= 1) {
	int i = 0;
	for (int dim = 0; dim &lt; amount_of_dimensions; dim += 1) {
		int ii = 1 & (coordinate[dim] >> shift);
		i |= ii &lt;&lt; dim;
	}
	index &lt;&lt;= amount_of_dimensions;
	index |= i;
}
</code></pre>
	There is a ton of bitshifting and masking here, since we're essentially interleaving the coordinates into the single index.
</p>
	<h3>Dissimilar dimension sizes</h3>
<p>
	If the smallest dimension size is very dissimilar from the largest dimension size,
	many bits in the coarse splitting stages stay unused. Our straightforward "concatenate all bits" approach is
	<em>too</em> straightforward for these cases.
</p><p>
	Aside from being able to take advantage of bitshifts (an advantage not to be underappreciated), there is no strict reason
	to always split things in two. We could be splitting any number of ways, though if we want to avoid indexing with fractions,
	the best we can do is splitting along prime factors. This significantly increases the complexity of both the math and the code,
	and additionally adds a lot of integer divides to the program, but it's still interesting to look at.
</p><p>
	Let's take the following dimension sizes as an example: 525, 66, 2275.
	We'll organize their prime factors in another table:
<table>
	<tr> <td>&nbsp;</td>  <th>dim 0</th> <th>dim 1</th> <th>dim 2</th> </tr>
	<tr> <th>split 0</th> <td>7</td>     <td> </td>     <td>13</td>    </tr>
	<tr> <th>split 1</th> <td>5</td>     <td>11</td>    <td>7</td>     </tr>
	<tr> <th>split 2</th> <td>5</td>     <td>3</td>     <td>5</td>     </tr>
	<tr> <th>split 3</th> <td>2</td>     <td>2</td>     <td>5</td>     </tr>
</table>
</p><p>
	Multiplying the rows gives the following sizes for the levels of resolution:
<table>
	<tr> <th>level 0</th> <th>level 1</th> <th>level 2</th> <th>level 3</th> </tr>
	<tr> <td>91</td>      <td>385</td>     <td>75</td>      <td>30</td>     </tr>
</table>
</p><p>
	Deriving coordinates into this space from standard coordinates is where a lot of the added complexity comes in.
	Decomposing to the coordinate at one level means you have to divide by the prime factors of the other levels.
<pre><code class="c">int index =
385*75*30*(x/(5*5*3) +            z/(7*5*5) ) +
    75*30*(x/(7*5*3) + y/(3*2)  + z/(13*5*5)) +
       30*(x/(7*5*3) + y/(11*2) + z/(13*7*5)) +
          (x/(7*5*5) + y/(11*3) + z/(13*7*5));
</code></pre>
	or
<pre><code class="c">int index =
385*75*30*((7*x)/525 +             (13*z)/2275) +
    75*30*((5*x)/525 + (11*y)/66 +  (5*z)/2275) +
       30*((5*x)/525 +  (3*y)/66 +  (5*z)/2275) +
          ((3*x)/525 +  (2*y)/66 +  (2*z)/2275);
</code></pre>
	There is a gap where the second dimension does not supply enough prime factors, but we could insert 1 as a filler number here,
	since <code>y/66</code> will always be less than 1.
<pre><code class="c">int index = 0;
for (int level = amount_of_factors - 1; level >= 0; level -= 1) {
	index *= level_sizes[level];
	for (int dim = amount_of_dimensions - 1; dim >= 0; dim -= 1) {
		index += (factors[dim][level]*coordinate[dim])/dimension_sizes[dim];
	}
}
</code></pre>
</p>
