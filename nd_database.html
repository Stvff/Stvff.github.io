<h1>N-Dimensional database with decent locality</h1>
<p>
	At some point in a person's life, there comes a time where a dataset has more than one dimension.
	It is imperative to their career that the datastructure they choose for this is regular,
	and ordered for the most relevant dimension(s).
</p><p>
	What we will be doing today is none of that. We want to be cool and esoteric with it.<br/>
	We want a datastructure where similar coordinates in space result in similar indices in linear memory.
	An important implication of this is that selecting a subsection of the total dataset becomes a more local
	operation as well, regardless of the direction or dimensionality that subsection has.
</p>
	<h2>The normal approach</h2>
<p>
	The standard way to save any amount of dimensions in a contiguous array is where every dimension consists of its subdimensions.
	A 2D array is a collection of many 1D lines, a 3D array is a collection of 2D slices, and so forth.
	Any particular coordinate is indexed like so:
<pre><code class="c">int index = 0;
for (int dim = amount_of_dimensions - 1; dim > 0; dim -= 1) {
	index *= dimension_sizes[dim];
	index += coordinate[dim];
}
</code></pre>
	A notable assumption here is that any particular dimension will have a maximum index (a size). This is a reasonable assumption,
	so in this article, we will accept it.
</p><p>
	This approach is great for a number of reasons, and can be tailored for datasets where one thing is more important than another.
	However, it lacks locality. Incrementing along the 'lower' dimensions results in small index changes, but these index distances
	increase rapidly as you increment along the 'higher' dimensions.
</p><p>
	This 'favoritism' for lower dimensions is the problem of interest, and one we'd like to solve.
</p>
	<h2>A more local approach</h2>
<p>
	To explain this, let's take a 3D example of an array with the following dimensions:
<pre><code>int dimension_sizes[3];
dimension_sizes[0] = 525;
dimension_sizes[1] = 66;
dimension_sizes[2] = 2275;
</code></pre>
	given a coordinate (<code>x, y, z</code>) and using the given method, the index would be:
<pre><code>int index = 66*575*z + 575*y + x;
</code></pre>
</p><p>
	Now we'll take a small leap of faith, and decompose the dimension sizes into their prime factors.
<pre><code>int dimension_sizes[3];
dimension_sizes[0] = 2 * 5 * 5 * 7 ;
dimension_sizes[1] = 2 * 3 * 11    ;
dimension_sizes[2] = 5 * 5 * 7 * 13;
</code></pre>
</p>
